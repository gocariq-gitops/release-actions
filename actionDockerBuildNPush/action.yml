name: "Docker Build and Push"
description: "Build Docker image and Push to GCR"

inputs:
  google_credentials:
    description: "Google Credentials"
    required: true
  google_project_id:
    description: "Google Project Id"
    required: true
  registry_host:
    default: "us-docker.pkg.dev"
    description: "Docker registry path"
  docker_file_path:
    description: "Docker File Path"
    required: true
  docker_image_name:
    description: "Docker Image Name"
    required: true
  docker_registry_name:
    default: "carig"
    description: "Docker Registry Name"
    required: true
  docker_params:
    description: "Docker build params"
  docker_params_token_on_build:
    default: "false"
    description: "Use docker build arg '--build-arg token=secrets.GHA_DEVOPS_DISPATCH' if is true"
    required: false
  docker_build_kit:
    default: "1"
    description: "Build kit some images are not building with 1"
  generate_gcp_general_secret:
    default: ""
    description: "Generate gcp-general.json file to be able to build some applications"
  generate_gcp_pypi_secret:
    default: "false"
    description: "Generate gcp-pypi.json file to be able to build some applications"
  gcp_sa_project_accessor:
    default: ""
    description: "GCP_SA_PROJECT_ACCESSOR secret for gcp-pypi.json generation to able to build some applications"
    required: false
  gha_devops_dispatch_token:
    default: ""
    description: "GitHub actions DevOps dispatch token"
    required: false
  dry_run:
    description: "Dry Run (do not deploy if checked)"
    default: "false"
    required: false

runs:
  using: "composite"
  steps:

    # TODO - All applications should be updated to read GCP credentials from environment variable
    - name: Save credentials for build steps for python packages
      if: ${{ inputs.generate_gcp_pypi_secret == 'true' }}
      shell: bash
      env:
        GCP_SA_GHA_IMAGEPUSH: ${{ inputs.google_credentials }}
      run: |
        echo "$GCP_SA_GHA_IMAGEPUSH" >> gcp-pypi.json

    - name: 'Authenticate to Google Cloud'
      if: ${{ inputs.generate_gcp_general_secret != '' }}
      id: GCPAuth2
      uses: gocariq-gitops/release-actions/actionGCPAuth@v2
      with:
        google_credentials: ${{ inputs.gcp_sa_project_accessor }}
        google_project_id: ${{ inputs.project_id }}

    - name: Save credentials for build steps for some images
      if: ${{ inputs.generate_gcp_general_secret != '' }}
      shell: bash
      run: |
        gcloud secrets versions access latest \
        --secret=${{ inputs.generate_gcp_general_secret }} \
        --format='get(payload.data)' | tr '_-' '/+' | base64 -d > \
        gcp-general.json

    - name: 'Authenticate to Google Cloud'
      if: ${{ inputs.generate_gcp_general_secret != '' }}
      id: GCPAuth
      uses: gocariq-gitops/release-actions/actionGCPAuth@v2
      with:
        google_credentials: ${{ inputs.google_credentials }}
        google_project_id: ${{ inputs.project_id }}
    # TODO - All applications should be updated to read GCP credentials from environment variable ^^^

    - name: Docker Auth with gCloud CLI
      shell: bash
      run: |
        gcloud auth configure-docker ${{inputs.registry_host}}

    - name: Building docker containers
      shell: bash
      run: |
        set -x
  
        # Set variables                      
        IMAGE_TAGGED_VER="${{inputs.docker_image_name}}:${{env.CURRENT_APP_VERSION}}"
        IMAGE_LATEST="${{inputs.docker_image_name}}:latest"
        IMAGE_FULL_PATH_TAGGED_VER="${{inputs.registry_host}}/${{inputs.google_project_id}}/${{inputs.docker_registry_name}}/${IMAGE_TAGGED_VER}"
        IMAGE_FULL_PATH_LATEST="${{inputs.registry_host}}/${{inputs.google_project_id}}/${{inputs.docker_registry_name}}/${IMAGE_LATEST}"
  
        # Check image exist in the registry
        if gcloud container images describe $IMAGE_FULL_PATH >/dev/null 2>&1; then
          echo "Image already exists."
          echo "DOCKER PUSH IS SKIPPED"
        fi
  
        # Add build argument token if required
        cd ${{inputs.docker_file_path}}
        [[ -r ~/.netrc ]] && cp ~/.netrc ./.netrc
        if [[ "${{ inputs.docker_params_token_on_build }}" == "true" ]]; then
          DOCKER_BUILDKIT=${{inputs.docker_build_kit}} docker build --build-arg token=${{inputs.gha_devops_dispatch_token}} ${{inputs.docker_params}} -t "$IMAGE_TAGGED_VER" -t "$IMAGE_LATEST" .
        else
          DOCKER_BUILDKIT=${{inputs.docker_build_kit}} docker build ${{inputs.docker_params}} -t "$IMAGE_TAGGED_VER" -t "$IMAGE_LATEST" .
        fi
        cd -
        
        # Push image if it does not exist in the registry
        if [[ "${{ inputs.dry_run }}" != "false" ]]; then
          docker tag $IMAGE_TAGGED_VER $IMAGE_FULL_PATH_TAGGED_VER
          docker tag $IMAGE_LATEST $IMAGE_FULL_PATH_LATEST
          docker push $IMAGE_FULL_PATH_TAGGED_VER
          docker push $IMAGE_FULL_PATH_LATEST
        else
          echo "Dry Run mode, no image is pushed to the registry."
        fi
